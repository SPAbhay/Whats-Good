from datetime import timedelta, datetimeimport uvicornfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, Request, APIRouter, statusfrom fastapi.security import OAuth2PasswordBearerfrom fastapi.middleware.cors import CORSMiddlewarefrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy import select, and_from fastapi.responses import JSONResponsefrom typing import Dict, Optionalimport jsonimport asynciofrom contextlib import asynccontextmanagerfrom .api.auth import router as auth_router, get_current_userfrom .db.base_class import get_async_sessionfrom .models import Article, Brand, Userfrom .models.brand import BrandQuestionnaireResponse, BrandResponsefrom .services.brand_processor import BrandProcessorfrom .core.config import Settingsfrom .services.chat.memory_store.redis_memory_store import RedisMemoryStorefrom .services.chat.memory_store.context_manager import ChatContextManagerfrom .services.chat.orchestrator import MainOrchestratorimport ossettings = Settings()router = APIRouter()oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")class ConnectionManager:    def __init__(self):        self.active_connections: Dict[str, WebSocket] = {}        self._lock = asyncio.Lock()  # Add lock for thread safety    async def connect(self, websocket: WebSocket, client_id: str):        async with self._lock:            try:                # Close existing connection if any                if client_id in self.active_connections:                    try:                        await self.active_connections[client_id].close()                    except Exception:                        pass                    try:                        del self.active_connections[client_id]                    except KeyError:                        pass                await websocket.accept()                self.active_connections[client_id] = websocket                print(f"Client {client_id} connected. Total connections: {len(self.active_connections)}")            except Exception as e:                print(f"Error in connect: {e}")                try:                    await websocket.close()                except Exception:                    pass    async def disconnect(self, client_id: str):        async with self._lock:            if client_id in self.active_connections:                try:                    await self.active_connections[client_id].close()                except Exception:                    pass                try:                    del self.active_connections[client_id]                except KeyError:                    pass                print(f"Client {client_id} disconnected. Total connections: {len(self.active_connections)}")    async def cleanup_connections(self):        """Remove dead connections"""        async with self._lock:            for client_id, connection in list(self.active_connections.items()):                try:                    await connection.ping()                except Exception:                    await self.disconnect(client_id)    async def send_message(self, message: str, client_id: str):        async with self._lock:            if client_id in self.active_connections:                try:                    await self.active_connections[client_id].send_text(message)                    print(f"Message sent to client {client_id}")                except Exception as e:                    print(f"Error sending message to client {client_id}: {str(e)}")                    await self.disconnect(client_id)manager = ConnectionManager()import logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)@asynccontextmanagerasync def lifespan(app: FastAPI):    # Startup: create background tasks    cleanup_task = asyncio.create_task(periodic_cleanup())    yield    # Shutdown: cleanup    cleanup_task.cancel()    try:        await cleanup_task    except asyncio.CancelledError:        passasync def periodic_cleanup():    while True:        await asyncio.sleep(30)  # Run every 30 seconds        try:            await manager.cleanup_connections()        except Exception as e:            print(f"Error in cleanup: {e}")app = FastAPI(    title="WhatsGood API",    lifespan=lifespan)allowed_origins = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000,https://whats-good.up.railway.app.com").split(",")# CORS middleware configurationapp.add_middleware(    CORSMiddleware,    allow_origins=allowed_origins,    allow_credentials=True,    allow_methods=["*"],    allow_headers=["*"],    expose_headers=["*"])# Include the auth routerapp.include_router(auth_router, prefix="/auth", tags=["authentication"])memory_store = RedisMemoryStore(settings=settings)context_manager = ChatContextManager(memory_store=memory_store)chat_orchestrator = MainOrchestrator(context_manager=context_manager)@app.websocket("/ws/{client_id}")async def websocket_endpoint(        websocket: WebSocket,        client_id: str,        db: AsyncSession = Depends(get_async_session)):    logger.info(f"WebSocket connection attempt from client: {client_id}")    await manager.connect(websocket, client_id)    logger.info(f"WebSocket connection established for client: {client_id}")    try:        while True:            try:                data = await websocket.receive_text()                message_data = json.loads(data)                logger.info(f"Received message data: {message_data}")                # Send processing status                await websocket.send_json({                    "type": "status",                    "content": "processing",                    "message": "Processing your request..."                })                # Get current context                chat_context = await context_manager.get_chat_context(                    article_id=message_data.get('article_id'),                    brand_id=int(message_data.get('brand_id'))                )                logger.info("Chat context retrieved")                # Process message                try:                    response = await chat_orchestrator.process_message(                        message=message_data.get('message'),                        context={                            "article_id": message_data.get('article_id'),                            "brand_id": int(message_data.get('brand_id')),                            "platform": message_data.get("platform", "General"),                            "chat_context": chat_context,                            "websocket": websocket                        }                    )                    logger.info(f"Generated response: {response}")                    # Ensure response is sent                    await websocket.send_json({                        "type": "message",                        "content": response.content,                        "metadata": {                            "platform": message_data.get("platform", "General"),                            "confidence": response.confidence_score,                            **response.metadata                        }                    })                    logger.info("Response sent to client")                except Exception as e:                    logger.error(f"Error processing message: {str(e)}")                    await websocket.send_json({                        "type": "error",                        "error": str(e),                        "message": "Failed to process message"                    })            except WebSocketDisconnect:                logger.info(f"WebSocket disconnected for client: {client_id}")                break            except json.JSONDecodeError as e:                logger.error(f"Invalid JSON: {str(e)}")                await websocket.send_json({                    "type": "error",                    "error": "Invalid message format"                })            except Exception as e:                logger.error(f"Websocket error: {str(e)}")                await websocket.send_json({                    "type": "error",                    "error": str(e),                    "message": "Failed to process message"                })    finally:        await manager.disconnect(client_id)        logger.info(f"Cleaned up connection for client: {client_id}")@app.get("/api/articles")async def get_articles(db: AsyncSession = Depends(get_async_session)):    try:        query = select(Article).order_by(Article.publish_date.desc()).limit(10)        result = await db.execute(query)        articles = result.scalars().all()        return [{            "article_id": article.article_id,            "title": article.title,            "author": article.author,            "category": article.category,            "summarized_content": article.summarized_content,            "publish_date": article.publish_date.isoformat() if article.publish_date else None,            "main_topic": article.topic_1        } for article in articles]    except Exception as e:        raise HTTPException(status_code=500, detail=str(e))@app.get("/api/articles/{article_id}")async def get_article(article_id: str, db: AsyncSession = Depends(get_async_session)):    try:        # Print debug information        print(f"Fetching article with ID: {article_id}")        query = select(Article).where(and_(Article.article_id == str(article_id)))        result = await db.execute(query)        article = result.scalar_one_or_none()        if not article:            raise HTTPException(status_code=404, detail=f"Article with ID {article_id} not found")        # Print debug information        print(f"Found article: {article.title}")        return {            "article_id": article.article_id,            "title": article.title,            "author": article.author,            "source_url": article.source_url,            "publish_date": article.publish_date.isoformat() if article.publish_date else None,            "category": article.category,            "summarized_content": article.summarized_content,            "topics": [                article.topic_1,                article.topic_2,                article.topic_3,                article.topic_4,                article.topic_5            ],            "insights": article.insights,            "created_at": article.created_at.isoformat() if article.created_at else None        }    except Exception as e:        print(f"Error fetching article: {str(e)}")        raise HTTPException(status_code=500, detail=str(e))@app.post("/api/articles/{article_id}/init-chat")async def initialize_chat_session(    article_id: str,    current_user: User = Depends(get_current_user),    db: AsyncSession = Depends(get_async_session)):    print(f"Initializing chat session for article: {article_id}")    try:        # Get article        query = select(Article).where(and_(Article.article_id == str(article_id)))        result = await db.execute(query)        article = result.scalar_one_or_none()        if not article:            print(f"Article not found: {article_id}")            raise HTTPException(status_code=404, detail=f"Article not found")        # Get user's brand        brand_query = select(Brand).where(and_(Brand.user_id == current_user.id))        result = await db.execute(brand_query)        brand = result.scalar_one_or_none()        if not brand:            print("No brand found for user")            raise HTTPException(                status_code=400,                detail="Please complete your brand profile first"            )        # Initialize chat context        success = await context_manager.initialize_chat_context(            db=db,            article_id=article_id,            brand_id=brand.id        )        if not success:            raise HTTPException(                status_code=500,                detail="Failed to initialize chat context"            )        return {            "status": "success",            "article_id": article_id,            "brand_id": brand.id        }    except HTTPException as he:        raise he    except Exception as e:        print(f"Error in initialize_chat_session: {str(e)}")        raise HTTPException(status_code=500, detail=str(e))# Optional: Delete endpoint if needed@router.delete("/brand/profile")async def delete_brand_profile(        current_user: User = Depends(get_current_user),        db: AsyncSession = Depends(get_async_session)):    query = select(Brand).where(and_(Brand.user_id == current_user.id))    result = await db.execute(query)    brand = result.scalar_one_or_none()    if not brand:        raise HTTPException(            status_code=status.HTTP_404_NOT_FOUND,            detail="Brand profile not found"        )    try:        await db.delete(brand)        await db.commit()        return {"message": "Brand profile deleted successfully"}    except Exception as e:        await db.rollback()        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=str(e)        )@app.get("/health")async def health_check():    return JSONResponse(content={        "status": "healthy",        "timestamp": datetime.now().isoformat(),        "env": settings.ENV,        "cors_origins": settings.get_cors_origins()    })@app.get("/")async def root():    return JSONResponse(content={        "status": "online",        "version": "1.0.0",        "timestamp": datetime.now().isoformat(),        "env": settings.ENV,        "documentation": "/docs"    })# Add error handling@app.exception_handler(404)async def custom_404_handler(request: Request, exc: HTTPException):    return JSONResponse(        status_code=404,        content={            "error": "Not Found",            "message": "The requested resource does not exist",            "path": request.url.path,            "available_endpoints": [                "/",                "/health",                "/docs",                "/auth/login",                "/auth/signup",                "/api/articles"            ]        }    )if __name__ == "__main__":    uvicorn.run("app.main:app", host="0.0.0.0", port=8000)