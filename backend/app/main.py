from datetime import timedelta, datetimefrom fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, Request, APIRouter, statusfrom fastapi.security import OAuth2PasswordBearerfrom fastapi.middleware.cors import CORSMiddlewarefrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy import select, and_from typing import Dict, Optionalimport jsonimport asynciofrom contextlib import asynccontextmanagerfrom .api.auth import router as auth_router, get_current_userfrom .db.base_class import get_async_sessionfrom .models import Article, Brand, Userfrom .models.brand import BrandQuestionnaireResponse, BrandResponsefrom .services.brand_processor import BrandProcessorfrom ..core.config import Settingsfrom .services.chat.memory_store.redis_memory_store import RedisMemoryStorefrom .services.chat.memory_store.context_manager import ChatContextManagerfrom .services.chat.orchestrator import MainOrchestratorsettings = Settings()router = APIRouter()oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")class ConnectionManager:    def __init__(self):        self.active_connections: Dict[str, WebSocket] = {}        self._lock = asyncio.Lock()  # Add lock for thread safety    async def connect(self, websocket: WebSocket, client_id: str):        async with self._lock:            try:                # Close existing connection if any                if client_id in self.active_connections:                    try:                        await self.active_connections[client_id].close()                    except Exception:                        pass                    try:                        del self.active_connections[client_id]                    except KeyError:                        pass                await websocket.accept()                self.active_connections[client_id] = websocket                print(f"Client {client_id} connected. Total connections: {len(self.active_connections)}")            except Exception as e:                print(f"Error in connect: {e}")                try:                    await websocket.close()                except Exception:                    pass    async def disconnect(self, client_id: str):        async with self._lock:            if client_id in self.active_connections:                try:                    await self.active_connections[client_id].close()                except Exception:                    pass                try:                    del self.active_connections[client_id]                except KeyError:                    pass                print(f"Client {client_id} disconnected. Total connections: {len(self.active_connections)}")    async def cleanup_connections(self):        """Remove dead connections"""        async with self._lock:            for client_id, connection in list(self.active_connections.items()):                try:                    await connection.ping()                except Exception:                    await self.disconnect(client_id)    async def send_message(self, message: str, client_id: str):        async with self._lock:            if client_id in self.active_connections:                try:                    await self.active_connections[client_id].send_text(message)                    print(f"Message sent to client {client_id}")                except Exception as e:                    print(f"Error sending message to client {client_id}: {str(e)}")                    await self.disconnect(client_id)manager = ConnectionManager()import logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)@asynccontextmanagerasync def lifespan(app: FastAPI):    # Startup: create background tasks    cleanup_task = asyncio.create_task(periodic_cleanup())    yield    # Shutdown: cleanup    cleanup_task.cancel()    try:        await cleanup_task    except asyncio.CancelledError:        passasync def periodic_cleanup():    while True:        await asyncio.sleep(30)  # Run every 30 seconds        try:            await manager.cleanup_connections()        except Exception as e:            print(f"Error in cleanup: {e}")app = FastAPI(    title="WhatsGood API",    lifespan=lifespan)# Add CORS middlewareapp.add_middleware(    CORSMiddleware,    allow_origins=["http://localhost:3000"],    allow_credentials=True,    allow_methods=["*"],    allow_headers=["*"],)# Include the auth routerapp.include_router(auth_router, prefix="/auth", tags=["authentication"])memory_store = RedisMemoryStore(settings=settings)context_manager = ChatContextManager(memory_store=memory_store)chat_orchestrator = MainOrchestrator(context_manager=context_manager)@app.websocket("/ws/{client_id}")async def websocket_endpoint(    websocket: WebSocket,    client_id: str,    db: AsyncSession = Depends(get_async_session)):    logger.info(f"WebSocket connection attempt from client: {client_id}")    await manager.connect(websocket, client_id)    logger.info(f"WebSocket connection established for client: {client_id}")    try:        while True:            try:                data = await websocket.receive_text()                message_data = json.loads(data)                logger.info(f"Received message data: {message_data}")                # Regular message processing                await websocket.send_json({                    "type": "status",                    "content": "processing",                    "message": "Processing your request..."                })                try:                    article_id = int(message_data.get("article_id"))                    brand_id = int(message_data.get("brand_id"))                except (TypeError, ValueError) as e:                    await websocket.send_json({                        "type": "error",                        "error": f"Invalid article or brand ID format: {str(e)}"                    })                    continue                # Get current context                chat_context = await context_manager.get_chat_context(                    article_id=article_id,                    brand_id=brand_id                )                # Process message                response = await chat_orchestrator.process_message(                    message=message_data.get("message"),                    context={                        "article_id": article_id,                        "brand_id": brand_id,                        "platform": message_data.get("platform", "General"),                        "chat_context": chat_context,                        "websocket": websocket                    }                )                # Send response                await websocket.send_json({                    "type": "message",                    "content": response.content,                    "metadata": {                        "platform": message_data.get("platform", "General"),                        "confidence": response.confidence_score,                        **response.metadata                    }                })            except WebSocketDisconnect:                logger.info(f"WebSocket disconnected for client: {client_id}")                break            except Exception as e:                logger.error(f"Error in websocket loop: {e}")                await websocket.send_json({                    "type": "error",                    "error": str(e),                    "message": "Failed to process message"                })    finally:        await manager.disconnect(client_id)        logger.info(f"Cleaned up connection for client: {client_id}")@app.get("/api/articles")async def get_articles(db: AsyncSession = Depends(get_async_session)):    query = select(Article)    result = await db.execute(query)    articles = result.scalars().all()    return articles@app.get("/api/articles/{article_id}")async def get_article(article_id: int, db: AsyncSession = Depends(get_async_session)):    query = select(Article).where(and_(Article.id == article_id))    result = await db.execute(query)    article = result.scalar_one_or_none()    if not article:        raise HTTPException(status_code=404, detail="Article not found")    return article@app.post("/api/articles/{article_id}/init-chat")async def initialize_chat_session(    article_id: int,    db: AsyncSession = Depends(get_async_session)):    try:        # Get article from database        query = select(Article).where(and_(Article.id == article_id))        result = await db.execute(query)        article = result.scalar_one_or_none()        if not article:            raise HTTPException(status_code=404, detail="Article not found")        # Initialize chat context        success = await context_manager.initialize_chat_context(            db=db,            article_id=article_id,            brand_id=1  # Replace with dynamic brand ID when implemented        )        if not success:            raise HTTPException(status_code=500, detail="Failed to initialize chat context")        return {"status": "success", "article_id": article_id}    except Exception as e:        raise HTTPException(status_code=500, detail=str(e))@router.post("/brand/questionnaire", response_model=BrandResponse)async def submit_brand_questionnaire(        questionnaire: BrandQuestionnaireResponse,        current_user: User = Depends(get_current_user),        db: AsyncSession = Depends(get_async_session)):    # Check if user already has a brand    query = select(Brand).where(and_(Brand.user_id == current_user.id))    result = await db.execute(query)    existing_brand = result.scalar_one_or_none()    if existing_brand:        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST,            detail="Brand profile already exists for this user"        )    try:        # Create new brand entry        new_brand = Brand(            user_id=current_user.id,            # Raw responses            raw_brand_name=questionnaire.raw_brand_name,            raw_industry_focus=questionnaire.raw_industry_focus,            raw_target_audience=questionnaire.raw_target_audience,            raw_unique_value=questionnaire.raw_unique_value,            raw_social_platforms=questionnaire.raw_social_platforms,            raw_successful_content=questionnaire.raw_successful_content        )        db.add(new_brand)        await db.commit()        await db.refresh(new_brand)        # Process and refine responses        processor = BrandProcessor()        processed_brand = await processor.process_brand_responses(new_brand.id, db)        return new_brand    except Exception as e:        await db.rollback()        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=str(e)        )@router.get("/brand/profile", response_model=BrandResponse)async def get_brand_profile(        current_user: User = Depends(get_current_user),        db: AsyncSession = Depends(get_async_session)):    query = select(Brand).where(and_(Brand.user_id == current_user.id))    result = await db.execute(query)    brand = result.scalar_one_or_none()    if not brand:        raise HTTPException(            status_code=status.HTTP_404_NOT_FOUND,            detail="Brand profile not found"        )    return brand@router.put("/brand/questionnaire", response_model=BrandResponse)async def update_brand_questionnaire(        questionnaire: BrandQuestionnaireResponse,        current_user: User = Depends(get_current_user),        db: AsyncSession = Depends(get_async_session)):    query = select(Brand).where(and_(Brand.user_id == current_user.id))    result = await db.execute(query)    existing_brand = result.scalar_one_or_none()    if not existing_brand:        raise HTTPException(            status_code=status.HTTP_404_NOT_FOUND,            detail="Brand profile not found"        )    try:        # Update existing brand        for field, value in questionnaire.model_dump().items():            setattr(existing_brand, field, value)        await db.commit()        await db.refresh(existing_brand)        return existing_brand    except Exception as e:        await db.rollback()        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=str(e)        )# Optional: Delete endpoint if needed@router.delete("/brand/profile")async def delete_brand_profile(        current_user: User = Depends(get_current_user),        db: AsyncSession = Depends(get_async_session)):    query = select(Brand).where(and_(Brand.user_id == current_user.id))    result = await db.execute(query)    brand = result.scalar_one_or_none()    if not brand:        raise HTTPException(            status_code=status.HTTP_404_NOT_FOUND,            detail="Brand profile not found"        )    try:        await db.delete(brand)        await db.commit()        return {"message": "Brand profile deleted successfully"}    except Exception as e:        await db.rollback()        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail=str(e)        )